/**
 * Script para importar archivos TXT de Anki a la base de datos
 * 
 * Formato esperado:
 * - Primera l√≠nea: #separator:tab (opcional)
 * - Segunda l√≠nea: #html:true (opcional)
 * - Resto: pregunta[TAB]respuesta
 */

const fs = require('fs');
const path = require('path');
const { query } = require('../lib/db');

// Configuraci√≥n
const TXT_FILE = process.argv[2]; // Ruta al archivo .txt
const SUBJECT_SLUG = process.argv[3] || 'gestion-software'; // Slug de la asignatura
const QUESTIONNAIRE_NAME = process.argv[4]; // Nombre del cuestionario

if (!TXT_FILE) {
  console.error('‚ùå Uso: node scripts/import_anki_txt.js <archivo.txt> [subject-slug] [nombre-cuestionario]');
  console.error('Ejemplo: node scripts/import_anki_txt.js ./deck.txt gestion-software "Parcial 2 24/25"');
  process.exit(1);
}

if (!fs.existsSync(TXT_FILE)) {
  console.error(`‚ùå El archivo ${TXT_FILE} no existe`);
  process.exit(1);
}

async function main() {
  console.log('üì¶ Importador de Anki TXT a Quizy\n');
  
  try {
    // 1. Leer archivo
    console.log('üìÇ Leyendo archivo...');
    const content = fs.readFileSync(TXT_FILE, 'utf-8');
    const lines = content.split('\n').filter(line => line.trim());
    console.log(`‚úì ${lines.length} l√≠neas encontradas`);

    // 2. Procesar l√≠neas (ignorar headers)
    const cards = [];
    for (let i = 2; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    const parts = line.split('\t');
    if (parts.length < 2) continue;

    // ¬°IMPORTANTE! En Anki TXT, las opciones se dividen entre campo 1 y 2
    // Campo 1: Pregunta + primeras opciones
    // Campo 2: Respuestas correctas + opciones restantes
    // Necesitamos UNIR ambos campos antes de parsear
    const combinedText = parts[0] + '<br>' + parts[1];
    const questionText = combinedText;
    const answerText = parts[1];

    // Skip image-based questions
    if (questionText.includes('<img') || answerText.includes('<img')) {
      console.log(`‚ö†Ô∏è  Pregunta ${i-1}: Contiene imagen - omitida`);
      skipped++;
      continue;
    }

    console.log(`‚úì ${cards.length} tarjetas encontradas`);

    if (cards.length === 0) {
      console.log('‚ö†Ô∏è  No se encontraron tarjetas');
      return;
    }

    // 3. Verificar/crear asignatura
    console.log(`\nüéì Verificando asignatura "${SUBJECT_SLUG}"...`);
    let subjectResult = await query(
      'SELECT id FROM subjects WHERE slug = $1',
      [SUBJECT_SLUG]
    );

    let subjectId;
    if (subjectResult.rows.length === 0) {
      console.log('‚ö†Ô∏è  Asignatura no encontrada. Cre√°ndola...');
      const name = SUBJECT_SLUG.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      const insertResult = await query(
        'INSERT INTO subjects (name, slug) VALUES ($1, $2) RETURNING id',
        [name, SUBJECT_SLUG]
      );
      subjectId = insertResult.rows[0].id;
      console.log(`‚úì Asignatura creada con ID: ${subjectId}`);
    } else {
      subjectId = subjectResult.rows[0].id;
      console.log(`‚úì Asignatura encontrada con ID: ${subjectId}`);
    }

    // 4. Procesar preguntas
    console.log(`\nüìã Procesando ${cards.length} preguntas...`);
    let successCount = 0;
    let errorCount = 0;
    const questionsArray = [];

    for (const card of cards) {
      try {
        const questionRaw = stripHTML(card.question);
        const answerRaw = stripHTML(card.answer);

        if (!questionRaw || !answerRaw) {
          console.log('‚ö†Ô∏è  Pregunta o respuesta vac√≠a, omitiendo...');
          errorCount++;
          continue;
        }

        // Detectar si es una pregunta con imagen
        const hasImageInQuestion = card.question.includes('<img') || card.question.includes('paste-');
        const hasImageInAnswer = card.answer.includes('<img') || card.answer.includes('paste-');
        
        if (hasImageInQuestion && hasImageInAnswer) {
          // Pregunta completamente en imagen - omitir
          console.log('üì∑ Pregunta con imagen detectada - omitiendo');
          errorCount++;
          continue;
        }

        // Separar enunciado y opciones del campo pregunta
        const parsed = parseQuestionWithOptions(questionRaw);
        
        if (!parsed || !parsed.options || parsed.options.length === 0) {
          console.log('‚ö†Ô∏è  No se pudieron extraer opciones de la pregunta, omitiendo...');
          console.log(`    Pregunta: ${questionRaw.substring(0, 80)}...`);
          errorCount++;
          continue;
        }

        // Si el enunciado est√° vac√≠o o es muy corto (solo n√∫meros o s√≠mbolos), crear uno b√°sico
        let finalStatement = parsed.statement.trim();
        if (finalStatement.length < 10 || /^[\d\s\.\-""]*$/.test(finalStatement)) {
          finalStatement = `Selecciona la opci√≥n correcta:`;
        }

        // Limpiar respuesta de comillas extras
        let cleanAnswer = answerRaw
          .replace(/^["']|["']$/g, '')
          .replace(/\s+/g, ' ')
          .trim();

        // Identificar qu√© opciones son correctas bas√°ndose en la respuesta
        const correctIndices = findCorrectOptions(parsed.options, cleanAnswer);
        
        if (correctIndices.length === 0) {
          console.log(`‚ö†Ô∏è  No se pudo identificar la respuesta correcta para: ${parsed.statement.substring(0, 50)}...`);
          errorCount++;
          continue;
        }

        // Convertir opciones a formato con keys de letras
        const optionsWithLetterKeys = parsed.options.map((opt, idx) => ({
          key: String.fromCharCode(97 + idx), // a, b, c, d...
          text: opt.text
        }));

        // Convertir √≠ndices de respuestas correctas a letras
        const answersAsLetters = correctIndices.map(idx => String.fromCharCode(97 + idx));

        questionsArray.push({
          id: successCount + 1, // ID √∫nico incremental
          question: finalStatement,
          options: optionsWithLetterKeys,
          answers: answersAsLetters
        });

        successCount++;
      } catch (err) {
        console.error(`‚ùå Error procesando tarjeta:`, err.message);
        errorCount++;
      }
    }

    // 5. Crear cuestionario
    if (questionsArray.length === 0) {
      console.log('‚ùå No se pudieron procesar preguntas. Abortando.');
      process.exit(1);
    }

    const questionnaireTitle = QUESTIONNAIRE_NAME || 
      path.basename(TXT_FILE, '.txt').replace(/_/g, ' ');
    
    console.log(`\nüìù Creando cuestionario "${questionnaireTitle}"...`);

    const bankResult = await query(
      `INSERT INTO question_banks (name, subject_id, questions, created_by, is_published) 
       VALUES ($1, $2, $3, $4, false) 
       RETURNING id`,
      [questionnaireTitle, subjectId, JSON.stringify(questionsArray), 'system']
    );
    const bankId = bankResult.rows[0].id;

    console.log(`\n‚úÖ Importaci√≥n completada:`);
    console.log(`   - ${successCount} preguntas importadas`);
    console.log(`   - ${errorCount} errores`);
    console.log(`\nüìä Cuestionario creado: "${questionnaireTitle}" (ID: ${bankId})`);
    console.log(`   Estado: No publicado (puedes publicarlo desde el panel de admin)`);

  } catch (error) {
    console.error('\n‚ùå Error durante la importaci√≥n:', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

// Utilidades
function stripHTML(html) {
  return html
    .replace(/<br\s*\/?>/gi, '\n') // Convertir <br> a saltos de l√≠nea ANTES de eliminar tags
    .replace(/<[^>]*>/g, '') // Eliminar tags HTML
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/[ \t]+/g, ' ') // M√∫ltiples espacios/tabs a uno solo (pero NO eliminar \n)
    .trim();
}

function parseQuestionWithOptions(text) {
  // Primero, buscar el marcador "Selecciona una" o similar
  const selectMarkerMatch = text.match(/Selecciona una.*?:/i);
  let startOfOptions = selectMarkerMatch ? text.indexOf(selectMarkerMatch[0]) + selectMarkerMatch[0].length : 0;
  
  // Buscar opciones despu√©s del marcador (o desde el principio si no hay marcador)
  const textAfterMarker = text.substring(startOfOptions);
  
  // Patr√≥n mejorado: letra seguida de punto, luego texto hasta el siguiente salto de l√≠nea o siguiente opci√≥n
  const optionPattern = /\n([a-h])\.\s+([^\n]+)/gi;
  
  const options = [];
  let match;
  let firstOptionIndex = -1;
  
  while ((match = optionPattern.exec(textAfterMarker)) !== null) {
    if (firstOptionIndex === -1) {
      firstOptionIndex = match.index;
    }
    
    const letter = match[1].toLowerCase();
    const optionText = match[2].trim();
    
    // Validar que el texto de la opci√≥n no est√© vac√≠o y no sea otro enunciado
    if (optionText.length > 0 && optionText.length < 300) {
      options.push({
        letter: letter,
        text: optionText
      });
    }
  }
  
  if (options.length === 0) {
    // Intentar sin requerir salto de l√≠nea antes (para casos donde no hay \n)
    const fallbackPattern = /([a-h])\.\s+([^a-h\.]{3,}?)(?=\s+[a-h]\.\s+|$)/gi;
    
    while ((match = fallbackPattern.exec(textAfterMarker)) !== null) {
      if (firstOptionIndex === -1) {
        firstOptionIndex = match.index;
      }
      
      const letter = match[1].toLowerCase();
      const optionText = match[2].trim();
      
      if (optionText.length > 0 && optionText.length < 300) {
        options.push({
          letter: letter,
          text: optionText
        });
      }
    }
  }
  
  if (options.length === 0) {
    // Verificar si es Verdadero/Falso
    if (text.toLowerCase().includes('verdadero') && text.toLowerCase().includes('falso')) {
      const statement = text.replace(/verdadero|falso/gi, '').replace(/Selecciona una.*/i, '').trim();
      return {
        statement: statement,
        options: [
          { letter: 'a', text: 'Verdadero' },
          { letter: 'b', text: 'Falso' }
        ]
      };
    }
    return null;
  }
  
  // El enunciado es todo lo que est√° antes de las opciones
  let statement = '';
  if (selectMarkerMatch && firstOptionIndex >= 0) {
    // Hay un marcador "Selecciona una", el enunciado est√° antes
    statement = text.substring(0, text.indexOf(selectMarkerMatch[0])).trim();
  } else if (firstOptionIndex >= 0) {
    // No hay marcador, el enunciado est√° antes de la primera opci√≥n
    statement = textAfterMarker.substring(0, firstOptionIndex).trim();
  } else {
    statement = text.trim();
  }
  
  return {
    statement,
    options
  };
}

function findCorrectOptions(options, answerText) {
  const correctIndices = [];
  
  // Buscar qu√© opciones aparecen en la respuesta
  options.forEach((opt, idx) => {
    // Verificar si la letra est√° en la respuesta
    const letterPattern = new RegExp(`\\b${opt.letter}\\.`, 'i');
    if (letterPattern.test(answerText)) {
      correctIndices.push(idx);
      return;
    }
    
    // Verificar si el texto de la opci√≥n aparece en la respuesta
    if (answerText.toLowerCase().includes(opt.text.toLowerCase())) {
      correctIndices.push(idx);
    }
  });
  
  return correctIndices;
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

main().catch(console.error);
